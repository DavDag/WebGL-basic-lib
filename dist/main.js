var WebGLBasicLib;(()=>{"use strict";var t={d:(s,e)=>{for(var i in e)t.o(e,i)&&!t.o(s,i)&&Object.defineProperty(s,i,{enumerable:!0,get:e[i]})},o:(t,s)=>Object.prototype.hasOwnProperty.call(t,s),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},s={};t.r(s),t.d(s,{BasicShape:()=>_,Camera:()=>r,Colors:()=>i,Cube:()=>B,Debug:()=>e,DebugShape:()=>U,Generable:()=>T,Icosahedron:()=>V,KeyboardHandler:()=>h,LinesFromTriangles:()=>z,Mat2:()=>R,Mat3:()=>P,Mat4:()=>S,MatrixStack:()=>a,MouseHandler:()=>u,Program:()=>d,ResizeHandler:()=>v,RetrieveWebGLContext:()=>n,SetKeyboardHandler:()=>o,SetMouseHandler:()=>l,SetResizeHandler:()=>c,Shader:()=>g,Shape:()=>F,Sphere:()=>I,Texture:()=>f,TexturedShape:()=>L,Vec2:()=>b,Vec3:()=>E,Vec4:()=>A,toDeg:()=>y,toRad:()=>p});class e{static#t;static#s;static#e;static#i;static#r;static Initialize(t){e.#t=t,e.#s=t.createBuffer(),e.#e=t.createBuffer(),e.#i=new d(t),e.#i.attachShader(new g(t,t.VERTEX_SHADER,"\nattribute vec4 aPosition;\nuniform mat4 uMatrix;\nuniform float uPointSize;\nvoid main(void) {\n  gl_Position = uMatrix * aPosition;\n  gl_PointSize = uPointSize;\n}\n")),e.#i.attachShader(new g(t,t.FRAGMENT_SHADER,"\nprecision highp float;\nuniform vec4 uPointColor;\nvoid main(void) {\n  gl_FragColor = uPointColor;\n}\n")),e.#i.attributes([[0,"aPosition"]]),e.#i.link(),e.#i.declareUniforms([["uMatrix","Matrix4fv"],["uPointSize","1f"],["uPointColor","4fv"]]),e.#r=new d(t),e.#r.attachShader(new g(t,t.VERTEX_SHADER,"\nattribute vec4 aPosition;\nuniform mat4 uMatrix;\nvoid main(void) {\n  gl_Position = uMatrix * aPosition;\n}\n")),e.#r.attachShader(new g(t,t.FRAGMENT_SHADER,"\nprecision highp float;\nuniform vec4 uLineColor;\nvoid main(void) {\n  gl_FragColor = uLineColor;\n}\n")),e.#r.attributes([[0,"aPosition"]]),e.#r.link(),e.#r.declareUniforms([["uMatrix","Matrix4fv"],["uLineColor","4fv"]])}static drawPoints(t,s,i,r,a,n){e.#t.bindBuffer(e.#t.ARRAY_BUFFER,e.#s),e.#t.bufferData(e.#t.ARRAY_BUFFER,t,e.#t.DYNAMIC_DRAW),e.#t.enableVertexAttribArray(0),e.#t.vertexAttribPointer(0,3,e.#t.FLOAT,!1,4*s,0),e.#i.use(),e.#i.uMatrix.update(i.values),e.#i.uPointColor.update(a.values),e.#i.uPointSize.update(n),e.#t.drawArrays(e.#t.POINTS,0,r),e.#t.disableVertexAttribArray(0),d.unbind(e.#t),e.#t.bindBuffer(e.#t.ARRAY_BUFFER,null)}static drawLines(t,s,i,r,a,n){e.#t.bindBuffer(e.#t.ARRAY_BUFFER,e.#s),e.#t.bufferData(e.#t.ARRAY_BUFFER,t,e.#t.DYNAMIC_DRAW),e.#t.bindBuffer(e.#t.ELEMENT_ARRAY_BUFFER,e.#e),e.#t.bufferData(e.#t.ELEMENT_ARRAY_BUFFER,s,e.#t.DYNAMIC_DRAW),e.#t.enableVertexAttribArray(0),e.#t.vertexAttribPointer(0,3,e.#t.FLOAT,!1,4*i,0),e.#r.use(),e.#r.uMatrix.update(r.values),e.#r.uLineColor.update(n.values),e.#t.drawElements(e.#t.LINES,2*a,e.#t.UNSIGNED_SHORT,0),e.#t.disableVertexAttribArray(0),d.unbind(e.#t),e.#t.bindBuffer(e.#t.ARRAY_BUFFER,null),e.#t.bindBuffer(e.#t.ELEMENT_ARRAY_BUFFER,null)}}class i{static get Red(){return new E(1,0,0)}static get Green(){return new E(0,1,0)}static get Blue(){return new E(0,0,1)}static get White(){return new E(1,1,1)}static get Gray(){return new E(.5,.5,.5)}static get Black(){return new E(0,0,0)}static get Cyan(){return new E(0,1,1)}static get Pink(){return new E(1,0,1)}static get Yellow(){return new E(1,1,0)}static RgbToHsv(t){const[s,e,i]=[t.r,t.g,t.b],r=Math.max(s,e,i),a=r-Math.min(s,e,i);var n=0;return 0!==a&&(n=r===s?(e-i)/a%6:r===e?(i-s)/a+2:(s-e)/a+4,(n*=1/6)<0&&(n+=1)),new E(n,0===r?0:a/r,r)}static HsvToRgb(t){const[s,e,i]=[360*t.h,t.s,t.v],r=i*e,a=r*(1-Math.abs(s/60%2-1)),n=i-r,[u,l,h]=s<60?[r,a,0]:s<120?[a,r,0]:s<180?[0,r,a]:s<240?[0,a,r]:s<300?[a,0,r]:[r,0,a];return new E(u+n,l+n,h+n)}static HexToRgb(t){if(6!=(t=t.substring(t.indexOf("#")+1)).length)throw new Error("Unsupported format");const s=parseInt(t,16);return new E(s>>16&255,s>>8&255,s>>0&255).div(255)}static HexToRgba(t){if(8!=(t=t.substring(t.indexOf("#")+1)).length)throw new Error("Unsupported format");const s=parseInt(t,16);return new A(s>>24&255,s>>16&255,s>>8&255,s>>0&255).div(255)}}class r{#a=null;#n=null;#u=null;#l=null;#h=null;#o=null;#v=null;#c=null;#d=null;constructor(t,s,e,i,r,a,n){this.#a=!0,this.#n=S.Identity(),this.#u=t,this.#l=s,this.#h=e,this.#o=i,this.#v=r,this.#c=a,this.#d=n}get perspectiveMat(){return S.Perspective(p(this.#u),this.#l,this.#h,this.#o)}get lookatMat(){return S.LookAt(this.#v,this.#v.clone().add(this.#c),this.#d)}get mat(){return this.update(),this.#n}set ratio(t){this.#l=t,this.#a=!0}isDirty(){return this.#a}update(){this.#a&&(this.#a=!1,this.#n=S.Identity().apply(this.perspectiveMat).apply(this.lookatMat))}move(t){this.#a=!0,this.#v.add(t)}}class a{DEPTH_LIMIT=128;#g;constructor(){this.#g=[S.Identity()]}head(){return this.size()>0?this.#g[this.size()]:void 0}push(t){const s=this.#g[this.size()].clone().apply(t);if(this.#g.push(s)>=this.DEPTH_LIMIT+1)throw new Error("Stack depth reached its limit. Be sure to pop() the correct number of times.");return s}pop(){return this.size()>0?this.#g.pop():void 0}size(){return this.#g.length-1}}function n(t){const s=document.getElementById(t);if(null==s)throw new Error("Invalid element id");const e=s.getContext("webgl");if(null==e)throw new Error("WebGL is not supported");return e.canvasEl=s,e}class u{onMouseDown(t,s){}onMouseMove(t,s){}onMouseUp(t,s){}onMouseWheel(t,s){}onMouseOut(t){}}function l(t,s){const e=document.getElementById(t),i=function(t){for(var s=0,e=0;t;)s+=t.offsetLeft-t.scrollLeft+t.clientLeft,e+=t.offsetTop-t.scrollTop+t.clientTop,t=t.offsetParent;return new b(s,e)}(e),r=t=>new b(t.clientX,t.clientY).sub(i);e.addEventListener("mousedown",(t=>s.onMouseDown(t,r(t)))),e.addEventListener("mousemove",(t=>s.onMouseMove(t,r(t)))),e.addEventListener("mouseup",(t=>s.onMouseUp(t,r(t)))),e.addEventListener("wheel",(t=>s.onMouseWheel(t,r(t)))),e.addEventListener("mouseleave",(t=>s.onMouseOut(t)))}class h{OnKeyDown(t){}OnKeyUp(t){}}function o(t,s){document.getElementById(t),document.addEventListener("keydown",(t=>s.OnKeyDown(t))),document.addEventListener("keyup",(t=>s.OnKeyUp(t)))}class v{OnResize(t,s){}}function c(t,s){const e=document.getElementById(t);new ResizeObserver((function(t){t.forEach((t=>{if(!t.devicePixelContentBoxSize)throw new Error("Unsupported resize event");{const e=t.borderBoxSize[0].inlineSize,i=t.borderBoxSize[0].blockSize,r=t.devicePixelContentBoxSize[0].inlineSize,a=t.devicePixelContentBoxSize[0].blockSize,n=new b(e,i).round(0),u=new b(r,a).round(0);s.OnResize(n,u)}}))})).observe(e,{box:"content-box"})}class d{#t;constructor(t){this.#t=t,this.id=t.createProgram(),this.attrs=[]}attachShader(t){this.#t.attachShader(this.id,t.id)}link(){this.#t.linkProgram(this.id)}use(){this.#t.useProgram(this.id)}static unbind(t){t.useProgram(null)}attributes(t){this.attrs=t,t.forEach((([t,s,e,i,r],a)=>{this.#t.bindAttribLocation(this.id,a,t)}))}enableAttributes(){this.attrs.forEach((([t,s,e,i,r],a)=>{this.#t.enableVertexAttribArray(a),this.#t.vertexAttribPointer(a,s,e,!1,i,r)}))}disableAttributes(){this.attrs.forEach(((t,s)=>{this.#t.disableVertexAttribArray(s)}))}declareUniform(t,s){const e=(t,e)=>this["uniform"+s](t,e),i=this.#t.getUniformLocation(this.id,t);return this[t]={update:t=>e(i,t),id:i},this[t]}declareUniforms(t){t.forEach((([t,s])=>{this.declareUniform(t,s)}))}uniform1f(t,s){this.#t.uniform1f(t,s)}uniform1i(t,s){this.#t.uniform1i(t,s)}uniform2iv(t,s){this.#t.uniform2iv(t,s)}uniform2fv(t,s){this.#t.uniform2fv(t,s)}uniform3iv(t,s){this.#t.uniform3iv(t,s)}uniform3fv(t,s){this.#t.uniform3fv(t,s)}uniform4iv(t,s){this.#t.uniform4iv(t,s)}uniform4fv(t,s){this.#t.uniform4fv(t,s)}uniformMatrix2fv(t,s){this.#t.uniformMatrix2fv(t,!1,s)}uniformMatrix3fv(t,s){this.#t.uniformMatrix3fv(t,!1,s)}uniformMatrix4fv(t,s){this.#t.uniformMatrix4fv(t,!1,s)}}class g{#t;constructor(t,s,e){this.#t=t,this.id=null,this.src=e,this.type=s,this.#f()}#f(){const t=this.#t.createShader(this.type);this.#t.shaderSource(t,this.src),this.#t.compileShader(t);const s=this.#t.getShaderParameter(t,this.#t.COMPILE_STATUS),e=this.#t.getShaderInfoLog(t);if(s===this.#t.GL_FALSE||""!=e)throw new Error("{SHADER-ERROR}: "+e);this.id=t}}class f{#t;constructor(t,s,e){this.#t=t,this.id=s,this.image=e,this.level=0,this.internalFormat=t.RGBA,this.srcFormat=t.RGBA,this.srcType=t.UNSIGNED_BYTE}load(){this.#t.bindTexture(this.#t.TEXTURE_2D,this.id),this.#t.texImage2D(this.#t.TEXTURE_2D,this.level,this.internalFormat,this.srcFormat,this.srcType,this.image),this.#t.bindTexture(this.#t.TEXTURE_2D,null)}bind(){this.#t.activeTexture(this.#t.TEXTURE0),this.#t.bindTexture(this.#t.TEXTURE_2D,this.id),this.#t.texParameteri(this.#t.TEXTURE_2D,this.#t.TEXTURE_WRAP_S,this.#t.REPEAT),this.#t.texParameteri(this.#t.TEXTURE_2D,this.#t.TEXTURE_WRAP_T,this.#t.REPEAT),this.#t.texParameteri(this.#t.TEXTURE_2D,this.#t.TEXTURE_MIN_FILTER,this.#t.LINEAR),this.#t.texParameteri(this.#t.TEXTURE_2D,this.#t.TEXTURE_MAG_FILTER,this.#t.LINEAR),this.#t.generateMipmap(this.#t.TEXTURE_2D)}static fromUrl(t,s){return new Promise(((e,i)=>{const r=new Image;r.onload=()=>{const s=t.createTexture();e(new f(t,s,r))},r.onerror=t=>{i("Error loading the image.")},r.crossOrigin="",r.src=s}))}}const m=Math.PI/180,w=180/Math.PI;function p(t){return t%360*m}function y(t){return t*w%360}class x{values;constructor(t){this.values=new Float32Array(t)}static count(){throw new Error("count() not implemented")}static FromArray(t){throw new Error("FromArray() not implemented")}toString(t=20){return"["+[...this.values].map((s=>s.toFixed(t))).join(",")+"]"}equals(t){for(let s=0;s<this.constructor.count();++s)if(this.values[s]!==t.values[s])return!1;return!0}add(t){for(let s=0;s<this.constructor.count();++s)this.values[s]+=t.values[s];return this}sub(t){for(let s=0;s<this.constructor.count();++s)this.values[s]-=t.values[s];return this}mul(t){for(let s=0;s<this.constructor.count();++s)this.values[s]*=t;return this}div(t){for(let s=0;s<this.constructor.count();++s)this.values[s]/=t;return this}round(t){for(let s=0;s<this.constructor.count();++s)this.values[s]=this.values[s].toFixed(t);return this}floor(){for(let t=0;t<this.constructor.count();++t)this.values[t]=Math.floor(this.values[t]);return this}normalize(){return this.div(this.magnitude())}inverse(){for(let t=0;t<this.constructor.count();++t)this.values[t]=1/this.values[t];return this}negate(){for(let t=0;t<this.constructor.count();++t)this.values[t]=-this.values[t];return this}dot(t){let s=0;for(let e=0;e<this.constructor.count();++e)s+=this.values[e]*t.values[e];return s}magnitude(){return Math.sqrt(this.magnitudeSquared())}magnitudeSquared(){return this.dot(this)}transform(t){const s=this.clone();for(let e=0;e<this.constructor.count();++e)this.values[e]=t.row(e).dot(s);return this}clone(){return this.constructor.FromArray(this.values)}static All(t){return this.FromArray(new Array(this.count()).fill(t))}static Zeros(){return this.All(0)}static Ones(){return this.All(1)}}class A extends x{constructor(t,s,e,i){super([t,s,e,i])}static count(){return 4}static FromArray(t){return new A(t[0],t[1],t[2],t[3])}toVec2(){return new b(this.x,this.y)}toVec3(){return new E(this.x,this.y,this.z)}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set z(t){this.values[2]=t}set w(t){this.values[3]=t}set r(t){this.values[0]=t}set g(t){this.values[1]=t}set b(t){this.values[2]=t}set a(t){this.values[3]=t}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}get w(){return this.values[3]}get r(){return this.values[0]}get g(){return this.values[1]}get b(){return this.values[2]}get a(){return this.values[3]}}class E extends x{constructor(t,s,e){super([t,s,e])}static count(){return 3}static FromArray(t){return new E(t[0],t[1],t[2])}toVec2(){return new b(this.x,this.y)}toVec4(t){return new A(this.x,this.y,this.z,t)}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set z(t){this.values[2]=t}set r(t){this.values[0]=t}set g(t){this.values[1]=t}set b(t){this.values[2]=t}set h(t){this.values[0]=t}set s(t){this.values[1]=t}set v(t){this.values[2]=t}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}get r(){return this.values[0]}get g(){return this.values[1]}get b(){return this.values[2]}get h(){return this.values[0]}get s(){return this.values[1]}get v(){return this.values[2]}cross(t){const s=this.values[0],e=this.values[1],i=this.values[2];return this.values[0]=e*t.z-i*t.y,this.values[1]=i*t.x-s*t.z,this.values[2]=s*t.y-e*t.x,this}toUVofSphere(){const t=Math.atan2(this.values[0],this.values[2])/Math.PI/2+.5,s=Math.asin(-this.values[1])/(Math.PI/2)/2+.5;return new b(t,s)}}class b extends x{constructor(t,s){super([t,s])}toVec3(t){return new E(this.x,this.y,t)}toVec4(t,s){return new A(this.x,this.y,t,s)}static count(){return 2}static FromArray(t){return new b(t[0],t[1])}set x(t){this.values[0]=t}set y(t){this.values[1]=t}set w(t){this.values[0]=t}set h(t){this.values[1]=t}set u(t){this.values[0]=t}set v(t){this.values[1]=t}get x(){return this.values[0]}get y(){return this.values[1]}get w(){return this.values[0]}get h(){return this.values[1]}get u(){return this.values[0]}get v(){return this.values[1]}}class M{values;constructor(t){this.values=new Float32Array(t)}static count(){throw new Error("count() not implemented")}static side(){throw new Error("side() not implemented")}static FromArrayCM(t){throw new Error("FromArrayCM() not implemented")}static FromArrayRM(t){throw new Error("FromArrayRM() not implemented")}get(t,s){return this.values[s*this.constructor.side()+t]}set(t,s,e){this.values[s*this.constructor.side()+t]=e}toString(t=20){return"[\n"+new Array(this.constructor.side()).fill(0).map(((s,e)=>"\t"+this.row(e).toString(t))).join(",\n")+"\n]"}equals(t){for(let t=0;t<this.constructor.count();++t)if(this.values[t]!==vec.values[t])return!1;return!0}round(t){for(let s=0;s<this.constructor.count();++s)this.values[s]=this.values[s].toFixed(t);return this}transpose(){for(let t=0;t<this.constructor.side();++t)for(let s=t+1;s<this.constructor.side();++s){const e=this.get(t,s);this.set(t,s,this.get(s,t)),this.set(s,t,e)}return this}clone(){return this.constructor.FromArrayCM(this.values)}static Identity(){const t=new Array(this.count()).fill(0);for(let s=0;s<this.count();++s)s%(this.side()+1)==0&&(t[s]=1);return this.FromArrayCM(t)}static All(t){return this.FromArrayCM(new Array(this.count()).fill(t))}static Zeros(){return this.All(0)}static Ones(){return this.All(1)}}class R extends M{constructor(t,s,e,i){super([t,e,s,i])}static count(){return 4}static side(){return 2}static FromArrayCM(t){return new R(t[0],t[2],t[1],t[3])}static FromArrayRM(t){return new R(t[0],t[1],t[2],t[3])}row(t){return new b(this.values[0+t],this.values[2+t])}col(t){return new b(this.values[2*t+0],this.values[2*t+1])}apply(t){const s=this.values[0],e=this.values[1],i=this.values[2],r=this.values[3];return this.values[0]=s*t.values[0]+e*t.values[2],this.values[1]=s*t.values[1]+e*t.values[3],this.values[2]=i*t.values[0]+r*t.values[2],this.values[3]=i*t.values[1]+r*t.values[3],this}scale(t){return this.values[0]*=t.x,this.values[1]*=t.x,this.values[2]*=t.y,this.values[3]*=t.y,this}rotate(t){const s=Math.sin(t),e=Math.cos(t),i=this.values[0],r=this.values[1],a=this.values[2],n=this.values[3];return this.values[0]=i*e+a*s,this.values[1]=r*e+n*s,this.values[2]=i*-s+a*e,this.values[3]=r*-s+n*e,this}det(){return this.values[0]*this.values[3]-this.values[2]*this.values[1]}inverse(){const t=this.values[0],s=this.values[1],e=this.values[2],i=this.values[3];var r=t*i-e*s;if(0===r)throw new Error("Unable to inverse matrix if det is zero");return r=1/r,this.values[0]=i*r,this.values[1]=-s*r,this.values[2]=-e*r,this.values[3]=t*r,this}}class P extends M{constructor(t,s,e,i,r,a,n,u,l){super([t,i,n,s,r,u,e,a,l])}static count(){return 9}static side(){return 3}static FromArrayCM(t){return new P(t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8])}static FromArrayRM(t){return new P(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])}row(t){return new E(this.values[0+t],this.values[3+t],this.values[6+t])}col(t){return new E(this.values[3*t+0],this.values[3*t+1],this.values[3*t+2])}apply(t){const s=this.values[0],e=this.values[1],i=this.values[2],r=this.values[3],a=this.values[4],n=this.values[5],u=this.values[6],l=this.values[7],h=this.values[8];for(let o=0;o<3;++o){const v=t.values[3*o+0],c=t.values[3*o+1],d=t.values[3*o+2];this.values[3*o+0]=v*s+c*r+d*u,this.values[3*o+1]=v*e+c*a+d*l,this.values[3*o+2]=v*i+c*n+d*h}return this}translate(t){return this.values[6]+=t.x*this.values[0]+t.y*this.values[3],this.values[7]+=t.x*this.values[1]+t.y*this.values[4],this.values[8]+=t.x*this.values[2]+t.y*this.values[5],this}scale(t){return this.values[0]*=t.x,this.values[1]*=t.x,this.values[2]*=t.x,this.values[3]*=t.y,this.values[4]*=t.y,this.values[5]*=t.y,this}rotate(t){const s=this.values[0],e=this.values[1],i=this.values[2],r=this.values[3],a=this.values[4],n=this.values[5],u=(this.values[6],this.values[7],this.values[8],Math.sin(t)),l=Math.cos(t);return this.values[0]=l*s+u*r,this.values[1]=l*e+u*a,this.values[2]=l*i+u*n,this.values[3]=l*r-u*s,this.values[4]=l*a-u*e,this.values[5]=l*n-u*i,this}det(){const t=this.values[0],s=this.values[1],e=this.values[2],i=this.values[3],r=this.values[4],a=this.values[5],n=this.values[6],u=this.values[7],l=this.values[8];return t*(l*r-a*u)+s*(-l*i+a*n)+e*(u*i-r*n)}inverse(){const t=this.values[0],s=this.values[1],e=this.values[2],i=this.values[3],r=this.values[4],a=this.values[5],n=this.values[6],u=this.values[7],l=this.values[8],h=l*r-a*u,o=-l*i+a*n,v=u*i-r*n;var c=t*h+s*o+e*v;if(0===c)throw new Error("Unable to inverse matrix if det is zero");return c=1/c,this.values[0]=h*c,this.values[1]=(-l*s+e*u)*c,this.values[2]=(a*s-e*r)*c,this.values[3]=o*c,this.values[4]=(l*t-e*n)*c,this.values[5]=(-a*t+e*i)*c,this.values[6]=v*c,this.values[7]=(-u*t+s*n)*c,this.values[8]=(r*t-s*i)*c,this}}class S extends M{constructor(t,s,e,i,r,a,n,u,l,h,o,v,c,d,g,f){super([t,r,l,c,s,a,h,d,e,n,o,g,i,u,v,f])}static count(){return 16}static side(){return 4}static FromArrayCM(t){return new S(t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15])}static FromArrayRM(t){return new S(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}row(t){return new A(this.values[0+t],this.values[4+t],this.values[8+t],this.values[12+t])}col(t){return new A(this.values[4*t+0],this.values[4*t+1],this.values[4*t+2],this.values[4*t+3])}apply(t){const s=this.values[0],e=this.values[1],i=this.values[2],r=this.values[3],a=this.values[4],n=this.values[5],u=this.values[6],l=this.values[7],h=this.values[8],o=this.values[9],v=this.values[10],c=this.values[11],d=this.values[12],g=this.values[13],f=this.values[14],m=this.values[15];for(let w=0;w<4;++w){const p=t.values[4*w+0],y=t.values[4*w+1],x=t.values[4*w+2],A=t.values[4*w+3];this.values[4*w+0]=p*s+y*a+x*h+A*d,this.values[4*w+1]=p*e+y*n+x*o+A*g,this.values[4*w+2]=p*i+y*u+x*v+A*f,this.values[4*w+3]=p*r+y*l+x*c+A*m}return this}translate(t){return this.values[12]+=this.values[0]*t.x+this.values[4]*t.y+this.values[8]*t.z,this.values[13]+=this.values[1]*t.x+this.values[5]*t.y+this.values[9]*t.z,this.values[14]+=this.values[2]*t.x+this.values[6]*t.y+this.values[10]*t.z,this.values[15]+=this.values[3]*t.x+this.values[7]*t.y+this.values[11]*t.z,this}scale(t){return this.values[0]*=t.x,this.values[1]*=t.x,this.values[2]*=t.x,this.values[3]*=t.x,this.values[4]*=t.y,this.values[5]*=t.y,this.values[6]*=t.y,this.values[7]*=t.y,this.values[8]*=t.z,this.values[9]*=t.z,this.values[10]*=t.z,this.values[11]*=t.z,this}rotate(t,s){const e=Math.sin(t),i=Math.cos(t),r=1-i,a=this.values[0],n=this.values[1],u=this.values[2],l=this.values[3],h=this.values[4],o=this.values[5],v=this.values[6],c=this.values[7],d=this.values[8],g=this.values[9],f=this.values[10],m=this.values[11],w=s.x*s.x*r+i,p=s.y*s.x*r+s.z*e,y=s.z*s.x*r-s.y*e,x=s.x*s.y*r-s.z*e,A=s.y*s.y*r+i,E=s.z*s.y*r+s.x*e,b=s.x*s.z*r+s.y*e,M=s.y*s.z*r-s.x*e,R=s.z*s.z*r+i;return this.values[0]=a*w+h*p+d*y,this.values[1]=n*w+o*p+g*y,this.values[2]=u*w+v*p+f*y,this.values[3]=l*w+c*p+m*y,this.values[4]=a*x+h*A+d*E,this.values[5]=n*x+o*A+g*E,this.values[6]=u*x+v*A+f*E,this.values[7]=l*x+c*A+m*E,this.values[8]=a*b+h*M+d*R,this.values[9]=n*b+o*M+g*R,this.values[10]=u*b+v*M+f*R,this.values[11]=l*b+c*M+m*R,this}det(){const t=this.values[0],s=this.values[1],e=this.values[2],i=this.values[3],r=this.values[4],a=this.values[5],n=this.values[6],u=this.values[7],l=this.values[8],h=this.values[9],o=this.values[10],v=this.values[11],c=this.values[12],d=this.values[13],g=this.values[14],f=t*a-s*r,m=t*n-e*r,w=s*n-e*a,p=l*d-h*c,y=l*g-o*c,x=h*g-o*d;return u*(t*x-s*y+e*p)-i*(r*x-a*y+n*p)+this.values[15]*(l*w-h*m+o*f)-v*(c*w-d*m+g*f)}inverse(){const t=this.values[0],s=this.values[1],e=this.values[2],i=this.values[3],r=this.values[4],a=this.values[5],n=this.values[6],u=this.values[7],l=this.values[8],h=this.values[9],o=this.values[10],v=this.values[11],c=this.values[12],d=this.values[13],g=this.values[14],f=this.values[15],m=t*a-s*r,w=t*n-e*r,p=t*u-i*r,y=s*n-e*a,x=s*u-i*a,A=e*u-i*n,E=l*d-h*c,b=l*g-o*c,M=l*f-v*c,R=h*g-o*d,P=h*f-v*d,S=o*f-v*g;var z=m*S-w*P+p*R+y*M-x*b+A*E;if(0===z)throw new Error("Unable to inverse matrix if det is zero");return z=1/z,this.values[0]=(a*S-n*P+u*R)*z,this.values[1]=(e*P-s*S-i*R)*z,this.values[2]=(d*A-g*x+f*y)*z,this.values[3]=(o*x-h*A-v*y)*z,this.values[4]=(n*M-r*S-u*b)*z,this.values[5]=(t*S-e*M+i*b)*z,this.values[6]=(g*p-c*A-f*w)*z,this.values[7]=(l*A-o*p+v*w)*z,this.values[8]=(r*P-a*M+u*E)*z,this.values[9]=(s*M-t*P-i*E)*z,this.values[10]=(c*x-d*p+f*m)*z,this.values[11]=(h*p-l*x-v*m)*z,this.values[12]=(a*b-r*R-n*E)*z,this.values[13]=(t*R-s*b+e*E)*z,this.values[14]=(d*w-c*y-g*m)*z,this.values[15]=(l*y-h*w+o*m)*z,this}static LookAt(t,s,e){if(t.equals(s))return S.Identity();const i=t.clone().sub(s).normalize(),r=e.clone().cross(i).normalize(),a=i.clone().cross(r).normalize(),n=new Array(16);return n[0]=r.x,n[1]=a.x,n[2]=i.x,n[3]=0,n[4]=r.y,n[5]=a.y,n[6]=i.y,n[7]=0,n[8]=r.z,n[9]=a.z,n[10]=i.z,n[11]=0,n[12]=-r.dot(t),n[13]=-a.dot(t),n[14]=-i.dot(t),n[15]=1,S.FromArrayCM(n)}static Perspective(t,s,e,i){const r=1/Math.tan(t/2),a=new Array(16);if(a[0]=r/s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=r,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[11]=-1,a[12]=0,a[13]=0,a[15]=0,r!==Number.Infinity){const t=1/(e-i);a[10]=(i+e)*t,a[14]=2*i*e*t}else a[10]=-1,a[14]=-2*e;return S.FromArrayCM(a)}}function z(t,s){const e=[],i=new Set;return s.forEach((s=>{[[s.x,s.y],[s.y,s.z],[s.z,s.x]].forEach((([s,r])=>{t[s],t[r];const a=Math.max(s,r)+"_"+Math.min(s,r);i.has(a)||(e.push(new b(s,r)),i.add(a))}))})),e}class T{static asBasicShape(t){const{verteces:s,triangles:e}=this._build(...arguments);return new _(s,e)}static asTexturedShape(t){const{verteces:s,uvs:e,triangles:i}=this._build(...arguments);return new L(s,e,i)}static asDebugShape(t){const{verteces:s,uvs:e,normals:i,triangles:r,lines:a}=this._build(...arguments);return new U(s,e,i,r,a)}static _build(){throw new Error("_build() not implemented")}}class F{verteces;numVerteces;triangles;numTriangles;constructor(t,s){this.verteces=new Float32Array(t),this.numVerteces=this.verteces.length/this.constructor.VertexSize(),this.triangles=new Uint16Array(s),this.numTriangles=this.triangles.length/3}static VertexSize(){throw new Error("VertexSize() not implemented")}vertexSize(){return this.constructor.VertexSize()}get bytes(){return 4*this.verteces.length+2*this.triangles.length}static flattenVecArray(t){return F.flattenVecArrays([t])}static flattenVecArrays(t){return t[0].map(((s,e)=>t.map((t=>[...t[e].values])).flat())).flat()}drawPoints(t,s,e){}drawLines(t,s){}}class _ extends F{constructor(t,s){super(F.flattenVecArray(t),F.flattenVecArray(s))}static VertexSize(){return 3}}class L extends F{constructor(t,s,e){super(F.flattenVecArrays([t,s]),F.flattenVecArray(e))}static VertexSize(){return 5}}class U extends F{lines;numLines;constructor(t,s,e,i,r){super(F.flattenVecArrays([t,s,e]),F.flattenVecArray(i)),this.lines=new Uint16Array(F.flattenVecArray(r)),this.numLines=this.lines.length/2}static VertexSize(){return 8}get bytes(){return super.bytes+2*this.lines.length}drawPoints(t,s,i){e.drawPoints(this.verteces,this.vertexSize(),t,this.numVerteces,s,i)}drawLines(t,s){e.drawLines(this.verteces,this.lines,this.vertexSize(),t,this.numLines,s)}}class B extends T{static _build(t){const s=[],e=[],i=[],r=[],a=new E(0,0,1),n=new E(0,0,-1),u=new E(-1,0,0),l=new E(1,0,0),h=new E(0,-1,0),o=new E(0,1,0);i.push(a,a,a,a,n,n,n,n,u,u,u,u,l,l,l,l,h,h,h,h,o,o,o,o);const v=()=>new E(-1,1,1),c=()=>new E(1,1,1),d=()=>new E(-1,-1,1),g=()=>new E(1,-1,1),f=()=>new E(-1,1,-1),m=()=>new E(1,1,-1),w=()=>new E(-1,-1,-1),p=()=>new E(1,-1,-1);return s.push(v(),d(),c(),g(),m(),p(),f(),w(),f(),w(),v(),d(),c(),g(),m(),p(),v(),c(),f(),m(),d(),g(),w(),p()),s.forEach((s=>s.mul(t/2))),e.push(...new Array(24).fill(b.Zeros())),r.push(new E(0,1,2),new E(1,2,3),new E(4,5,6),new E(5,6,7),new E(8,9,10),new E(9,10,11),new E(12,13,14),new E(13,14,15),new E(16,17,18),new E(17,18,19),new E(20,21,22),new E(21,22,23)),{verteces:s,uvs:e,normals:i,triangles:r,lines:z(s,r)}}}class I extends T{static _build(t,s){const e=Math.max(3,t),i=Math.max(3,s),r=[],a=[],n=[],u=[];for(let t=0;t<=e;++t)for(let s=0;s<=i;++s){const u=Math.PI*t/e,l=2*Math.PI*s/i,h=Math.sin(u)*Math.cos(l),o=Math.cos(u),v=Math.sin(u)*Math.sin(l),c=s/i,d=t/e;r.push(new E(h,o,v)),a.push(new b(c,d)),n.push(new E(h,o,v))}const l=i+1;for(let t=0;t<e;++t)for(let s=0;s<i;++s){const i=t*l,r=i+s,a=i+s+1,n=i+s+l,h=i+(s+1)%l;t!=e-1&&u.push(new E(r,n,h+l)),0!=t&&u.push(new E(r,a,h+l))}return{verteces:r,uvs:a,normals:n,triangles:u,lines:z(r,u)}}}class V extends T{static _build(t){t=Math.max(0,t);const s=[];var e,i,r,a=[];const n=.5257311121191336,u=.8506508083520399;s.push(new E(-n,0,u)),s.push(new E(n,0,u)),s.push(new E(-n,0,-u)),s.push(new E(n,0,-u)),s.push(new E(0,u,n)),s.push(new E(0,u,-n)),s.push(new E(0,-u,n)),s.push(new E(0,-u,-n)),s.push(new E(u,n,0)),s.push(new E(-u,n,0)),s.push(new E(u,-n,0)),s.push(new E(-u,-n,0)),a.push(new E(0,4,1)),a.push(new E(0,9,4)),a.push(new E(9,5,4)),a.push(new E(4,5,8)),a.push(new E(4,8,1)),a.push(new E(8,10,1)),a.push(new E(8,3,10)),a.push(new E(5,3,8)),a.push(new E(5,2,3)),a.push(new E(2,7,3)),a.push(new E(7,10,3)),a.push(new E(7,6,10)),a.push(new E(7,11,6)),a.push(new E(11,0,6)),a.push(new E(0,1,6)),a.push(new E(6,1,10)),a.push(new E(9,0,11)),a.push(new E(9,11,2)),a.push(new E(9,2,5)),a.push(new E(7,2,11));const l={};function h(t,e){const i=Math.max(t,e)+"_"+Math.min(t,e);if(!l[i]){const[r,a]=[s[t],s[e]],n=E.Zeros().add(r).add(a).normalize();l[i]=s.push(n)-1}return l[i]}for(let s=0;s<t;++s){const t=[];a.forEach((s=>{const e=h(s.x,s.y),i=h(s.y,s.z),r=h(s.z,s.x);t.push(new E(s.x,e,r)),t.push(new E(s.y,i,e)),t.push(new E(s.z,r,i)),t.push(new E(e,i,r))})),a=t}return r=z(s,a),i=s.map((t=>t.clone().normalize())),e=s.map((t=>t.toUVofSphere())),{verteces:s,uvs:e,normals:i,triangles:a,lines:r}}}WebGLBasicLib=s})();